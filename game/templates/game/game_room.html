{% extends 'game/base.html' %}
{% load i18n %}
{% load static %}

{% block title %}{% trans "Chess Game" %} #{{ game_id }}{% endblock %}

{% block content %}
<div class="max-w-4xl mx-auto">
    <div class="mb-4 flex justify-between items-center">
        <h2 class="text-2xl font-bold text-gray-800">{% trans "Game" %} #{{ game_id }}</h2>
        <div class="flex items-center">
            <button id="shareBtn" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded mr-3">
                {% trans "Share Link" %}
            </button>
            <span id="spectatorCount" class="text-gray-600">
                {% trans "Spectators" %}: <span id="spectatorNum">{{ game.spectator_count }}</span>
            </span>
        </div>
    </div>
    
    <!-- State 1: Visitor - Can choose available colors -->
    {% if user_state == 'visitor' and can_choose_color %}
    <div id="colorChoice" class="mb-6 p-4 bg-white rounded-lg shadow">
        <h3 class="text-lg font-medium text-gray-800 mb-3">{% trans "Choose Your Color" %}</h3>
        <div class="flex justify-center space-x-4">
            {% if 'white' in available_colors %}
            <button id="chooseWhite" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-6 py-3 rounded">
                {% trans "White" %}
            </button>
            {% else %}
            <button disabled class="bg-gray-100 text-gray-400 px-6 py-3 rounded cursor-not-allowed">
                {% trans "White" %} ({% trans "Reserved" %})
            </button>
            {% endif %}
            
            {% if 'black' in available_colors %}
            <button id="chooseBlack" class="bg-gray-800 hover:bg-gray-900 text-white px-6 py-3 rounded">
                {% trans "Black" %}
            </button>
            {% else %}
            <button disabled class="bg-gray-400 text-gray-300 px-6 py-3 rounded cursor-not-allowed">
                {% trans "Black" %} ({% trans "Reserved" %})
            </button>
            {% endif %}
        </div>
        <div id="reservationStatus" class="mt-3 text-sm text-gray-600 text-center"></div>
    </div>
    
    <!-- State 2: Color Reserved - Show timer and ready button -->
    {% elif user_state == 'color_reserved' %}
    <div id="colorReserved" class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg shadow">
        <h3 class="text-lg font-medium text-blue-800 mb-3">
            {% trans "Color Reserved" %}: 
            <span class="font-bold">
                {% if color_reserved == 'white' %}{% trans "White" %}{% else %}{% trans "Black" %}{% endif %}
            </span>
        </h3>
        <div class="text-center mb-4">
            <div id="reservationTimer" class="text-2xl font-mono text-blue-600 mb-2">
                <span id="timerMinutes">{{ reservation_minutes }}</span>:<span id="timerSeconds">{{ reservation_seconds }}</span>
            </div>
            <p class="text-sm text-blue-600">{% trans "Reservation expires in" %}</p>
        </div>
        <div class="flex justify-center space-x-3">
            <button id="readyBtn" class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded font-medium">
                {% trans "I am Ready!" %}
            </button>
            <button id="cancelReservationBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-3 rounded">
                {% trans "Cancel" %}
            </button>
        </div>
    </div>
    
    <!-- State 3: Player Ready - Show status -->
    {% elif user_state == 'player_ready' %}
    <div id="playerReady" class="mb-6 p-4 bg-green-50 border border-green-200 rounded-lg shadow">
        <h3 class="text-lg font-medium text-green-800 mb-3">
            {% trans "You are ready as" %} 
            <span class="font-bold">
                {% if player_color == 'white' %}{% trans "White" %}{% else %}{% trans "Black" %}{% endif %}
            </span>
        </h3>
        <div class="text-center">
            <div class="inline-flex items-center px-4 py-2 bg-green-100 rounded-full">
                <div class="w-2 h-2 bg-green-500 rounded-full mr-2 animate-pulse"></div>
                <span class="text-green-700 font-medium">{% trans "Waiting for opponent..." %}</span>
            </div>
        </div>
    </div>
    
    <!-- State 4: Visitor waiting (no colors available) -->
    {% elif user_state == 'visitor' and waiting_for_reservations %}
    <div id="waitingForReservations" class="mb-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg shadow">
        <h3 class="text-lg font-medium text-yellow-800 mb-3">{% trans "Game Organizing" %}</h3>
        <div class="text-center">
            <div class="inline-flex items-center px-4 py-2 bg-yellow-100 rounded-full">
                <div class="w-2 h-2 bg-yellow-500 rounded-full mr-2 animate-pulse"></div>
                <span class="text-yellow-700">{% trans "Players are choosing colors..." %}</span>
            </div>
        </div>
    </div>
    
    <!-- State 5: Spectator -->
    {% elif user_state == 'spectator' %}
    <div id="spectatorMode" class="mb-6 p-4 bg-gray-50 border border-gray-200 rounded-lg shadow">
        <h3 class="text-lg font-medium text-gray-800 mb-3">{% trans "Spectator Mode" %}</h3>
        <div class="text-center">
            <div class="inline-flex items-center px-4 py-2 bg-gray-100 rounded-full">
                <svg class="w-4 h-4 text-gray-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"/>
                    <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd"/>
                </svg>
                <span class="text-gray-700">{% trans "Watching the game" %}</span>
            </div>
        </div>
    </div>
    {% endif %}
    
    <div class="grid md:grid-cols-3 gap-6">
        <div class="md:col-span-2">
            <div id="boardContainer" class="bg-white rounded-lg shadow p-4 transition-colors duration-300">
                <div id="board" class="board-container"></div>
            </div>
        </div>
        
        <div class="md:col-span-1">
            <div class="bg-white rounded-lg shadow p-4">
                <div id="gameStatus" class="mb-4">
                    <h3 class="font-medium text-gray-800 mb-2">{% trans "Game Status" %}</h3>
                    <p id="statusText" class="text-gray-600">{% trans "Waiting for players..." %}</p>
                </div>
                
                <div id="playerInfo" class="mb-4">
                    <div class="flex items-center mb-2">
                        <div class="w-4 h-4 bg-white border border-gray-300 mr-2"></div>
                        <span id="whitePlayerStatus">{% trans "White" %}: 
                            {% if game.player_white %}
                                {% if game.white_ready %}{% trans "Ready" %}{% else %}{% trans "Not Ready" %}{% endif %}
                            {% else %}
                                {% trans "Waiting" %}
                            {% endif %}
                        </span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-4 h-4 bg-black border border-gray-300 mr-2"></div>
                        <span id="blackPlayerStatus">{% trans "Black" %}: 
                            {% if game.player_black %}
                                {% if game.black_ready %}{% trans "Ready" %}{% else %}{% trans "Not Ready" %}{% endif %}
                            {% else %}
                                {% trans "Waiting" %}
                            {% endif %}
                        </span>
                    </div>
                </div>
                
                {% if is_spectator %}
                <div class="mt-6 p-3 bg-gray-100 rounded">
                    <p class="text-gray-600 text-sm">{% trans "You are watching as a spectator" %}</p>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Game configuration
    const gameId = "{{ game_id }}";
    let playerColor = "{% if player_color %}{{ player_color }}{% else %}none{% endif %}";
    const isSpectator = {% if is_spectator %}true{% else %}false{% endif %};
    const canChooseColor = {% if can_choose_color %}true{% else %}false{% endif %};
    const csrfToken = "{{ csrf_token }}";
    
    // New reservation system state
    let userState = "{{ user_state }}";
    let colorReserved = "{% if color_reserved %}{{ color_reserved }}{% else %}none{% endif %}";
    let reservationTimer = null;
    let reservationExpiry = {% if reservation_expires_in %}{{ reservation_expires_in }}{% else %}0{% endif %};
    
    // Game state
    let gameActive = false;
    let gameStarted = "{{ game.status }}" === "active";
    let gameOver = false;
    let lastCheckState = false;
    let chess = new Chess(); // Initialize chess.js
    
    // Sound effects - preload and configure
    const sounds = {
        move: new Howl({ 
            src: [
                '{% static "sound/move-self.mp3" %}',
                '{% static "sound/move-self.ogg" %}'
            ],
            preload: true,
            volume: 1.0
        }),
        capture: new Howl({ 
            src: [
                '{% static "sound/capture.mp3" %}',
                '{% static "sound/capture.ogg" %}'
            ],
            preload: true,
            volume: 1.0
        }),
        check: new Howl({ 
            src: [
                '{% static "sound/check.mp3" %}',
                '{% static "sound/check.ogg" %}'
            ],
            preload: true,
            volume: 1.0
        }),
        start: new Howl({ 
            src: [
                '{% static "sound/game-start.mp3" %}',
                '{% static "sound/game-start.ogg" %}'
            ],
            preload: true,
            volume: 1.0
        }),
        yourTurn: new Howl({ 
            src: [
                '{% static "sound/your-turn.mp3" %}',
                '{% static "sound/your-turn.ogg" %}'
            ],
            preload: true,
            volume: 1.0
        })
    };
    
    // Test sound after page load
    window.addEventListener('load', function() {
        // Debug helper to check if sound is working
        console.log('Testing sound...');
        setTimeout(() => {
            try {
                sounds.move.play();
                console.log('Sound test complete');
            } catch (e) {
                console.error('Sound test failed:', e);
            }
        }, 2000);
    });
    
    // Board configuration - will be set up after color selection
    let boardConfig = {
        position: 'start',
        pieceTheme: function(piece) {
            return '{% static "img/chesspieces/wikipedia/" %}' + piece + '.png';
        },
        draggable: false, // Disable dragging - we'll use click-based movement instead
        orientation: '{% if player_color == "black" %}black{% else %}white{% endif %}'
    };
    
    // Track the selected piece and square for click-based movement
    let selectedSquare = null;
    
    // Initialize reservation system UI handlers
    initializeReservationHandlers();
    
    // Initialize countdown timer if user has a reservation
    if (userState === 'color_reserved' && reservationExpiry > 0) {
        startReservationCountdown(reservationExpiry);
    }
    
    // Initialize turn indicator on game load
    if (gameStarted) {
        initializeTurnIndicator();
    }
    
    // Setup share button
    const shareBtn = document.getElementById('shareBtn');
    if (shareBtn) {
        shareBtn.addEventListener('click', () => {
            const gameUrl = window.location.href;
            
            // Try modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(gameUrl).then(() => {
                    alert('{% trans "Game link copied to clipboard!" %}');
                }).catch((err) => {
                    console.error('Clipboard write failed:', err);
                    fallbackCopyToClipboard(gameUrl);
                });
            } else {
                // Fallback for older browsers or non-HTTPS
                fallbackCopyToClipboard(gameUrl);
            }
        });
    }
    
    // Fallback clipboard function
    function fallbackCopyToClipboard(text) {
        // Create a temporary textarea element
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        textArea.style.top = '-999999px';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            const successful = document.execCommand('copy');
            if (successful) {
                alert('{% trans "Game link copied to clipboard!" %}');
            } else {
                // If copy failed, show the URL to user
                prompt('{% trans "Copy this game link:" %}', text);
            }
        } catch (err) {
            console.error('Fallback copy failed:', err);
            // Final fallback: show the URL to user
            prompt('{% trans "Copy this game link:" %}', text);
        } finally {
            document.body.removeChild(textArea);
        }
    }
    
    // Initialize board and game
    let board = Chessboard('board', boardConfig);
    
    // Initialize turn indicator
    function initializeTurnIndicator() {
        if (!isSpectator && gameStarted) {
            const currentTurn = chess.turn();
            const isPlayerTurn = (currentTurn === 'w' && playerColor === 'white') || 
                              (currentTurn === 'b' && playerColor === 'black');
            
            if (isPlayerTurn) {
                $('#boardContainer').addClass('your-turn');
            }
        }
    }
    
    // Extend the board object with a highlight method
    board.highlightSquare = function(square, color) {
        const $square = $('#board .square-' + square);
        $square.css('background-color', color);
    };
    
    // Add a method to clear all highlights
    board.clearHighlights = function() {
        $('.chess-square').css('background-color', '');
        $('.highlight-square').removeClass('highlight-square');
        $('.selected-square').removeClass('selected-square');
        $('.highlight-move').removeClass('highlight-move');
    };
    
    // Add click-based movement for better mobile experience
    function setupClickBasedMovement() {
        console.log("Setting up direct square click handlers");
        
        // Add styles for highlighting
        if (!document.getElementById('selection-styles')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'selection-styles';
            styleEl.textContent = `
                .selected-square {
                    background-color: rgba(0, 128, 255, 0.3) !important;
                }
                .highlight-move {
                    background-color: rgba(0, 255, 0, 0.3) !important;
                }
                .highlight-square {
                    background-color: rgba(255, 255, 0, 0.3) !important;
                }
                .your-turn {
                    background-color: rgba(152, 251, 152, 0.3) !important;
                    box-shadow: 0 0 8px 2px rgba(0, 200, 0, 0.5);
                }
            `;
            document.head.appendChild(styleEl);
        }
        
        // Much simpler approach: directly use chessboard's squares
        // Remove any existing click handler
        $('#board .square-55d63').off('click');
        
        // Add click handler to all squares
        $('#board .square-55d63').on('click', function() {
            // Get the square from the class name
            const squareClasses = $(this).attr('class').split(' ');
            let square = null;
            
            // Find the square class (format: square-a1, square-h8, etc.)
            for (const cls of squareClasses) {
                if (cls.startsWith('square-') && cls !== 'square-55d63') {
                    square = cls.substring(7); // Remove 'square-' prefix
                    break;
                }
            }
            
            // If no square found in class, try to derive from position
            if (!square) {
                // This is a fallback in case we can't find the square in the class
                const squareElement = $(this);
                const board = $('#board');
                const isFlipped = board.hasClass('flipped');
                
                // Calculate relative position
                const offsetX = squareElement.position().left;
                const offsetY = squareElement.position().top;
                const boardWidth = board.width();
                const boardHeight = board.height();
                
                // Convert to file and rank (0-7)
                const fileIdx = Math.floor(offsetX / (boardWidth / 8));
                const rankIdx = Math.floor(offsetY / (boardHeight / 8));
                
                // Adjust for board orientation
                const adjustedFileIdx = isFlipped ? 7 - fileIdx : fileIdx;
                const adjustedRankIdx = isFlipped ? rankIdx : 7 - rankIdx;
                
                // Convert to algebraic notation
                const file = String.fromCharCode(97 + adjustedFileIdx); // 'a' to 'h'
                const rank = 8 - adjustedRankIdx; // 1 to 8
                square = file + rank;
            }
            
            console.log('Square clicked:', square);
            
            // Process the click
            handleSquareClick(square);
        });
        
        // Handle square clicks - now takes square name directly
        function handleSquareClick(square) {
            // Only allow moves if the game is started and not over
            if (!gameStarted || gameOver || isSpectator) {
                console.log('Move not allowed - game state:', { gameStarted, gameOver, isSpectator });
                return;
            }
            
            // If no square is selected yet
            if (selectedSquare === null) {
                // Check if there's a piece on this square
                const pieceType = chess.get(square);
                
                if (pieceType) {
                    const pieceColor = pieceType.color;
                    console.log('Piece:', pieceType, 'Color:', pieceColor);
                    
                    const isPlayerPiece = (pieceColor === 'w' && playerColor === 'white') || 
                                          (pieceColor === 'b' && playerColor === 'black');
                    
                    // Check if it's this player's turn
                    const currentTurn = chess.turn();
                    const isPlayerTurn = (currentTurn === 'w' && playerColor === 'white') || 
                                         (currentTurn === 'b' && playerColor === 'black');
                    
                    console.log('Player piece?', isPlayerPiece, 'Player turn?', isPlayerTurn);
                    
                    if (isPlayerPiece && isPlayerTurn) {
                        // Select the square
                        selectedSquare = square;
                        
                        // Highlight the selected square - uses board's internal squares
                        $('.selected-square').removeClass('selected-square');
                        $(`#board .square-${square}`).addClass('selected-square');
                        
                        // Highlight possible moves
                        highlightPossibleMoves(square);
                        console.log('Square selected:', square);
                    } else {
                        console.log('Cannot select this piece - not your piece or not your turn');
                    }
                } else {
                    console.log('No piece on this square');
                }
            } 
            // If the same square is selected, deselect it
            else if (selectedSquare === square) {
                console.log('Deselecting square:', square);
                selectedSquare = null;
                $('.selected-square').removeClass('selected-square');
                $('.highlight-move').removeClass('highlight-move');
            } 
            // If a different square is selected, try to move
            else {
                console.log('Attempting move from', selectedSquare, 'to', square);
                
                // Attempt the move
                const fromSquare = selectedSquare;
                makeClickMove(fromSquare, square)
                    .then((successful) => {
                        console.log('Move result:', successful ? 'success' : 'failed');
                        // Reset selection state
                        selectedSquare = null;
                        $('.selected-square').removeClass('selected-square');
                        $('.highlight-move').removeClass('highlight-move');
                    });
            }
        }
    }
    
    // Function to highlight possible moves for a piece
    function highlightPossibleMoves(square) {
        // Clear existing move highlights
        $('.highlight-move').removeClass('highlight-move');
        
        // Get all legal moves for the piece
        const moves = chess.moves({ square: square, verbose: true });
        
        // Highlight each possible destination using the actual chessboard squares
        moves.forEach(move => {
            $(`#board .square-${move.to}`).addClass('highlight-move');
        });
    }
    
    // Function to make a move when clicking
    async function makeClickMove(from, to) {
        // Check for pawn promotion
        const piece = chess.get(from);
        let promotion = null;
        
        if (piece && piece.type === 'p') {
            const sourceRank = parseInt(from[1]);
            const targetRank = parseInt(to[1]);
            
            // Check if pawn is moving to the last rank
            if ((piece.color === 'w' && targetRank === 8) || 
                (piece.color === 'b' && targetRank === 1)) {
                promotion = await promptPromotion(piece.color);
            }
        }
        
        // Use the existing onDrop logic for the actual move
        await handleMovement(from, to, promotion);
    }
    
    // Setup click handlers after board is initialized
    setupClickBasedMovement();
    
    // Setup event source for real-time updates
    const evtSource = new EventSource(`/${gameId}/events/`);
    evtSource.onmessage = function(event) {
        const gameState = JSON.parse(event.data);
        updateGameState(gameState);
    };
    
    // Close event source when page is closed
    window.addEventListener('beforeunload', () => {
        evtSource.close();
    });
    
    // Initialize reservation system event handlers
    function initializeReservationHandlers() {
        // State 1: Color choice buttons (visitor state)
        const chooseWhiteBtn = document.getElementById('chooseWhite');
        const chooseBlackBtn = document.getElementById('chooseBlack');
        
        if (chooseWhiteBtn) {
            chooseWhiteBtn.addEventListener('click', () => reserveColor('white'));
        }
        if (chooseBlackBtn) {
            chooseBlackBtn.addEventListener('click', () => reserveColor('black'));
        }
        
        // State 2: Ready and cancel buttons (color_reserved state)
        const readyBtn = document.getElementById('readyBtn');
        const cancelBtn = document.getElementById('cancelReservationBtn');
        
        if (readyBtn && userState === 'color_reserved') {
            readyBtn.addEventListener('click', markReady);
        }
        if (cancelBtn) {
            cancelBtn.addEventListener('click', cancelReservation);
        }
    }
    
    // Reserve a color (new reservation system)
    async function reserveColor(color) {
        try {
            // Prevent multiple simultaneous requests
            if (window.reservationInProgress) {
                return;
            }
            window.reservationInProgress = true;
            
            const response = await fetch(`/${gameId}/reserve_color/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken,
                },
                body: JSON.stringify({ color: color })
            });
            
            const result = await response.json();
            
            if (result.status === 'ok') {
                // Update local state
                userState = 'color_reserved';
                colorReserved = result.color;
                reservationExpiry = result.expires_in;
                
                // Hide color choice, show reservation UI
                const colorChoiceDiv = document.getElementById('colorChoice');
                if (colorChoiceDiv) {
                    colorChoiceDiv.style.display = 'none';
                }
                
                // Show reservation UI - reload page to get proper template state
                window.location.reload();
            } else {
                alert(result.message || 'Failed to reserve color');
            }
        } catch (error) {
            console.error('Error reserving color:', error);
            alert('Error reserving color');
        } finally {
            window.reservationInProgress = false;
        }
    }
    
    // Cancel color reservation
    async function cancelReservation() {
        try {
            const response = await fetch(`/${gameId}/cancel_reservation/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken,
                }
            });
            
            const result = await response.json();
            
            if (result.status === 'ok') {
                // Reload page to get updated state
                window.location.reload();
            } else {
                alert(result.message || 'Failed to cancel reservation');
            }
        } catch (error) {
            console.error('Error cancelling reservation:', error);
            alert('Error cancelling reservation');
        }
    }
    
    // Start countdown timer for color reservation
    function startReservationCountdown(secondsLeft) {
        // Clear any existing timer
        if (reservationTimer) {
            clearInterval(reservationTimer);
        }
        
        const timerMinutes = document.getElementById('timerMinutes');
        const timerSeconds = document.getElementById('timerSeconds');
        
        if (!timerMinutes || !timerSeconds) {
            return;
        }
        
        function updateTimer() {
            if (secondsLeft <= 0) {
                // Reservation expired - reload page
                clearInterval(reservationTimer);
                window.location.reload();
                return;
            }
            
            const minutes = Math.floor(secondsLeft / 60);
            const seconds = secondsLeft % 60;
            
            timerMinutes.textContent = minutes;
            timerSeconds.textContent = seconds.toString().padStart(2, '0');
            
            secondsLeft--;
        }
        
        // Update immediately
        updateTimer();
        
        // Update every second
        reservationTimer = setInterval(updateTimer, 1000);
    }
    
    // Function to choose color (legacy - now redirects to reserve)
    async function chooseColor(color) {
        try {
            // Store that we're making a selection so we don't try to make multiple
            if (window.colorSelectionInProgress) {
                return;
            }
            window.colorSelectionInProgress = true;
            
            const response = await fetch(`/${gameId}/choose_color/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken,
                },
                body: JSON.stringify({ color: color })
            });
            
            const result = await response.json();
            
            if (result.status === 'ok') {
                // Update the player color
                playerColor = result.color;
                const colorChoiceDiv = document.getElementById('colorChoice');
                if (colorChoiceDiv) {
                    colorChoiceDiv.classList.add('hidden');
                }
                
                // Add info about the chosen color
                let playerColorInfoDiv = document.getElementById('playerColorInfo');
                if (!playerColorInfoDiv) {
                    playerColorInfoDiv = document.createElement('div');
                    playerColorInfoDiv.id = 'playerColorInfo';
                    playerColorInfoDiv.className = 'mb-6 p-4 bg-white rounded-lg shadow';
                    document.querySelector('.md\\:col-span-2').parentNode.insertBefore(
                        playerColorInfoDiv, 
                        document.querySelector('.md\\:col-span-2').parentNode.firstChild
                    );
                }
                playerColorInfoDiv.innerHTML = `
                    <h3 class="text-lg font-medium text-gray-800 mb-3">{% trans "Your Color" %}</h3>
                    <div class="flex justify-center space-x-4">
                        <div class="py-3 px-6 rounded 
                            ${color === 'white' ? 'bg-gray-200 text-gray-800' : 'bg-gray-800 text-white'}">
                            ${color === 'white' ? '{% trans "White" %}' : '{% trans "Black" %}'}
                        </div>
                    </div>
                `;
                
                // Update board orientation
                board.orientation(color);
                isSpectator = false;
                
                // Update status
                updateStatusText();
                
                // Reinitialize click handlers
                setupClickBasedMovement();
            }
        } catch (error) {
            console.error('Error choosing color:', error);
        } finally {
            // Reset the selection flag
            window.colorSelectionInProgress = false;
        }
    }
    
    // Function to mark player as ready
    async function markReady() {
        if (isSpectator || !playerColor) return;
        
        try {
            // Immediately update UI to prevent double-clicks
            const readyBtn = document.getElementById('readyBtn');
            readyBtn.disabled = true;
            readyBtn.classList.add('bg-gray-400');
            readyBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
            readyBtn.textContent = '{% trans "Ready!" %}';
            
            const response = await fetch(`/${gameId}/ready/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken,
                }
            });
            
            const result = await response.json();
            
            if (result.status === 'ok') {
                // Update player color after marking ready
                if (colorReserved && colorReserved !== 'none') {
                    playerColor = colorReserved;
                    console.log('Player color set to:', playerColor);
                }
                
                if (result.game_started) {
                    gameStarted = true;
                    sounds.start.play();
                    updateStatusText();
                    
                    // Hide reservation UI and show game
                    const colorReservedDiv = document.getElementById('colorReserved');
                    if (colorReservedDiv) colorReservedDiv.style.display = 'none';
                    
                    // Update board orientation
                    if (playerColor !== 'none') {
                        board.orientation(playerColor);
                    }
                    
                    // Initialize turn indicator as the game just started
                    initializeTurnIndicator();
                    
                    console.log('Game started locally for player:', playerColor);
                }
            } else {
                // If there was an error, restore the button
                readyBtn.disabled = false;
                readyBtn.classList.remove('bg-gray-400');
                readyBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                readyBtn.textContent = '{% trans "I am Ready" %}';
                console.error('Failed to mark ready:', result.message);
            }
        } catch (error) {
            // If there was an error, restore the button
            const readyBtn = document.getElementById('readyBtn');
            readyBtn.disabled = false;
            readyBtn.classList.remove('bg-gray-400');
            readyBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
            readyBtn.textContent = '{% trans "I am Ready" %}';
            console.error('Error marking ready:', error);
        }
    }
    
    // Function to update game state from SSE
    function updateGameState(gameState) {
        console.log('Game state update:', gameState);
        
        // Get the previous turn before updating
        const previousTurn = chess.turn();
        
        // Clear selection when board updates
        selectedSquare = null;
        $('.selected-square').removeClass('selected-square');
        $('.highlight-move').removeClass('highlight-move');
        
        // Update board position
        board.position(gameState.fen);
        
        // Update chess.js position
        try {
            chess.load(gameState.fen);
        } catch (e) {
            console.log('Invalid FEN:', e);
        }
        
        // Update player information from SSE
        if (gameState.players) {
            // Determine current user's color from session context
            // This will be handled by the initial page load context
        }
        
        // Process reservation system updates
        updateReservationUI(gameState);
        
        // Game start logic
        if (gameState.status === 'active' && !gameStarted) {
            gameStarted = true;
            sounds.start.play();
            
            // Hide any reservation/ready UI when game starts
            const colorChoiceDiv = document.getElementById('colorChoice');
            const colorReservedDiv = document.getElementById('colorReserved');
            const playerReadyDiv = document.getElementById('playerReady');
            const waitingDiv = document.getElementById('waitingForReservations');
            
            if (colorChoiceDiv) colorChoiceDiv.style.display = 'none';
            if (colorReservedDiv) colorReservedDiv.style.display = 'none';
            if (playerReadyDiv) playerReadyDiv.style.display = 'none';
            if (waitingDiv) waitingDiv.style.display = 'none';
            
            // Hide UI elements and enable game board
            setupClickBasedMovement();
            
            console.log('Game started via SSE! Current player color:', playerColor);
        }
        
        // Highlight last move if available
        if (gameState.last_move) {
            const [from, to] = gameState.last_move.split('-');
            highlightLastMove(from, to);
        }
        
        // Check sound
        if (gameState.in_check && lastCheckState !== gameState.in_check) {
            sounds.check.play();
        }
        lastCheckState = gameState.in_check;
        
        // Game over logic
        if (gameState.game_over && !gameOver) {
            gameOver = true;
            handleGameOver(gameState);
        }
        
        // Update player ready states
        const whiteStatus = document.getElementById('whitePlayerStatus');
        const blackStatus = document.getElementById('blackPlayerStatus');
        
        if (gameState.white_ready) {
            whiteStatus.innerHTML = '{% trans "White" %}: {% trans "Ready" %}';
        }
        
        if (gameState.black_ready) {
            blackStatus.innerHTML = '{% trans "Black" %}: {% trans "Ready" %}';
        }
        
        // Update spectator count
        document.getElementById('spectatorNum').textContent = gameState.spectators;
        
        // Update status text
        updateStatusText(gameState);
        
        // Reset overlay when board updates
        setupClickBasedMovement();
        
        // Update the turn indicator and potentially play a sound
        updateTurnIndicator(previousTurn);
    }
    
    // Update reservation system UI based on SSE data
    function updateReservationUI(gameState) {
        if (!gameState.reservations) return;
        
        // Update available color buttons
        const chooseWhiteBtn = document.getElementById('chooseWhite');
        const chooseBlackBtn = document.getElementById('chooseBlack');
        
        if (chooseWhiteBtn) {
            const whiteAvailable = gameState.available_colors && gameState.available_colors.includes('white');
            chooseWhiteBtn.disabled = !whiteAvailable;
            if (!whiteAvailable) {
                chooseWhiteBtn.classList.add('cursor-not-allowed', 'bg-gray-100', 'text-gray-400');
                chooseWhiteBtn.classList.remove('bg-gray-200', 'hover:bg-gray-300', 'text-gray-800');
            }
        }
        
        if (chooseBlackBtn) {
            const blackAvailable = gameState.available_colors && gameState.available_colors.includes('black');
            chooseBlackBtn.disabled = !blackAvailable;
            if (!blackAvailable) {
                chooseBlackBtn.classList.add('cursor-not-allowed', 'bg-gray-400', 'text-gray-300');
                chooseBlackBtn.classList.remove('bg-gray-800', 'hover:bg-gray-900', 'text-white');
            }
        }
        
        // Update reservation status display
        const statusDiv = document.getElementById('reservationStatus');
        if (statusDiv) {
            let statusText = '';
            if (gameState.reservations.white.reserved) {
                const expires = Math.max(0, gameState.reservations.white.expires_in);
                statusText += `White reserved (${Math.ceil(expires)}s remaining) `;
            }
            if (gameState.reservations.black.reserved) {
                const expires = Math.max(0, gameState.reservations.black.expires_in);
                statusText += `Black reserved (${Math.ceil(expires)}s remaining)`;
            }
            statusDiv.textContent = statusText;
        }
    }
    
    // Function to update the turn indicator and play sound when it's the player's turn
    function updateTurnIndicator(previousTurn) {
        if (isSpectator || !gameStarted || gameOver) {
            return;
        }
        
        const $boardContainer = $('#boardContainer');
        const currentTurn = chess.turn();
        const isPlayerTurn = (currentTurn === 'w' && playerColor === 'white') || 
                          (currentTurn === 'b' && playerColor === 'black');
        
        // Remove the highlight first
        $boardContainer.removeClass('your-turn');
        
        // If it's the player's turn, add the highlight
        if (isPlayerTurn) {
            $boardContainer.addClass('your-turn');
            
            // If the turn has changed and it's now this player's turn
            if (previousTurn && previousTurn !== currentTurn) {
                // Play "your turn" sound
                sounds.yourTurn.play();
            }
        }
    }
    
    // Function to highlight the last move on the board
    function highlightLastMove(from, to) {
        // Clear existing highlights
        $('.highlight-square').removeClass('highlight-square');
        
        // Add new highlights if valid coordinates
        if (from && to) {
            $(`#board .square-${from}`).addClass('highlight-square');
            $(`#board .square-${to}`).addClass('highlight-square');
        }
    }
    
    // Function to handle game over scenarios
    function handleGameOver(gameState) {
        // Play appropriate sound
        if (gameState.status === 'checkmate') {
            sounds.check.play();  // Checkmate sound
        }
        
        // Display game result
        let resultMessage = '';
        if (gameState.result === 'white_win') {
            resultMessage = '{% trans "White wins by checkmate!" %}';
        } else if (gameState.result === 'black_win') {
            resultMessage = '{% trans "Black wins by checkmate!" %}';
        } else if (gameState.result === 'draw') {
            resultMessage = '{% trans "Game ends in a draw!" %}';
        } else if (gameState.status === 'stalemate') {
            resultMessage = '{% trans "Game ends in stalemate!" %}';
        }
        
        // Display the result message
        if (resultMessage) {
            const statusText = document.getElementById('statusText');
            statusText.innerHTML = `<strong>${resultMessage}</strong>`;
            
            // Disable further moves
            boardConfig.draggable = false;
            board = Chessboard('board', boardConfig);
        }
    }
    
    // Function to update the status text
    function updateStatusText(gameState) {
        const statusText = document.getElementById('statusText');
        
        if (!gameState) {
            if (!gameStarted) {
                statusText.textContent = '{% trans "Waiting for players to be ready..." %}';
            } else {
                statusText.textContent = '{% trans "Game in progress..." %}';
            }
            return;
        }
        
        // Handle different game states
        switch(gameState.status) {
            case 'waiting':
                statusText.textContent = '{% trans "Waiting for players to be ready..." %}';
                break;
                
            case 'active':
                let statusMessage = '';
                
                // Show whose turn it is
                if (gameState.turn === 'w') {
                    statusMessage = '{% trans "White to move" %}';
                } else {
                    statusMessage = '{% trans "Black to move" %}';
                }
                
                // Add check indicator
                if (gameState.in_check) {
                    statusMessage += ' — {% trans "CHECK!" %}';
                }
                
                statusText.textContent = statusMessage;
                break;
                
            case 'checkmate':
                // Determine winner
                let winner = gameState.turn === 'w' ? '{% trans "Black" %}' : '{% trans "White" %}';
                statusText.innerHTML = `<strong>${winner} {% trans "wins by checkmate!" %}</strong>`;
                break;
                
            case 'stalemate':
                statusText.innerHTML = '<strong>{% trans "Game ends in stalemate!" %}</strong>';
                break;
                
            case 'draw':
                statusText.innerHTML = '<strong>{% trans "Game ends in a draw!" %}</strong>';
                break;
                
            case 'abandoned':
                statusText.textContent = '{% trans "Game abandoned" %}';
                break;
                
            default:
                statusText.textContent = '{% trans "Game over" %}';
        }
    }
    
    // Handle movement logic (common to both click and drag interfaces)
    async function handleMovement(source, target, promotion = null) {
        console.log('Move requested:', source, target, promotion ? `promotion: ${promotion}` : '');
        
        // Validate move conditions
        if (isSpectator) {
            console.log('Spectators cannot move pieces');
            return false;
        }
        
        if (!gameStarted) {
            console.log('Game not started yet');
            return false;
        }
        
        if (gameOver) {
            console.log('Game is already over');
            return false;
        }
        
        // Check if it's this player's turn
        const currentTurn = chess.turn();
        const isPlayerTurn = (currentTurn === 'w' && playerColor === 'white') || 
                          (currentTurn === 'b' && playerColor === 'black');
        
        if (!isPlayerTurn) {
            console.log('Not your turn');
            return false;
        }
        
        // Check if the move is legal according to chess.js
        const move = chess.move({
            from: source,
            to: target,
            promotion: promotion
        });
        
        // If the move is not legal in chess.js, don't even try to send it to the server
        if (!move) {
            console.log('Illegal move according to chess.js');
            return false;
        }
        
        // Undo the move in chess.js - we'll let the server validate it properly
        chess.undo();
        
        // Remember the current position to reset to if needed
        const currentPosition = chess.fen();
        
        // Send the move to the server
        try {
            const moveData = { 
                from: source, 
                to: target 
            };
            
            if (promotion) {
                moveData.promotion = promotion;
            }
            
            const response = await fetch(`/${gameId}/move/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken,
                },
                body: JSON.stringify(moveData)
            });
            
            const result = await response.json();
            console.log('Move result:', result);
            
            if (result.status !== 'ok') {
                console.log('Move rejected:', result.message);
                // Reset the board position
                board.position(currentPosition);
                return false;
            }
            
            // Play appropriate sound based on move type
            const moveInfo = result.move_info || {};
            
            if (moveInfo.captured) {
                sounds.capture.play();
                console.log('Capture sound played');
            } else {
                sounds.move.play();
                console.log('Move sound played');
            }
            
            return true;
        } catch (error) {
            console.error('Error making move:', error);
            // Reset the board position
            board.position(currentPosition);
            return false;
        }
    }
    
    // Function to prompt for pawn promotion piece
    async function promptPromotion(color) {
        return new Promise(resolve => {
            // Default to queen if no selection made
            // For Phase 2, we'll just auto-promote to queen
            resolve('q');  // q = queen, r = rook, b = bishop, n = knight
            
            // In a more advanced implementation, you would show a UI to select the piece
        });
    }
</script>
{% endblock %}